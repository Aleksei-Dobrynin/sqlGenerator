using System.Data;
using Dapper;
using Domain.Entities;
using Application.Repositories;
using Infrastructure.Data.Models;
using Application.Exceptions;
using Application.Models;
using System;
using Infrastructure.FillLogData;

namespace Infrastructure.Repositories
{
    public class {{ entity_name }}Repository : I{{ entity_name }}Repository
    {
        private readonly IDbConnection _dbConnection;
        private IDbTransaction? _dbTransaction;
        private IUserRepository _userRepository;

        public {{ entity_name }}Repository(IDbConnection dbConnection, IUserRepository userRepository)
        {
            _dbConnection = dbConnection;
            _userRepository = userRepository;
        }

        public void SetTransaction(IDbTransaction dbTransaction)
        {
            _dbTransaction = dbTransaction;
        }

        public async Task<List<{{ entity_name }}>> GetAll()
        {
            try
            {
                var sql = "SELECT * FROM {{ table_name }}";
                var models = await _dbConnection.QueryAsync<{{ entity_name }}>(sql, transaction: _dbTransaction);
                return models.ToList();
            }
            catch (Exception ex)
            {
                throw new RepositoryException("Failed to get {{ entity_name }}", ex);
            }
        }

        public async Task<{{ entity_name }}> GetOneByID(int id)
        {
            try
            {
                var sql = "SELECT * FROM {{ table_name }} WHERE id = @Id LIMIT 1";
                var model = await _dbConnection.QuerySingleOrDefaultAsync<{{ entity_name }}>(sql, new { Id = id }, transaction: _dbTransaction);

                if (model == null)
                {
                    throw new RepositoryException($"{{ entity_name }} with ID {id} not found.", null);
                }

                return model;
            }
            catch (Exception ex)
            {
                throw new RepositoryException("Failed to get {{ entity_name }}", ex);
            }
        }

        public async Task<int> Add({{ entity_name }} domain)
        {
            try
            {
                var userId = await UserSessionHelper.SetCurrentUserAsync(_userRepository, _dbConnection, _dbTransaction);

                var model = new {{ entity_name }}
                {
{{~ for column in columns ~}}
{{~ if column.Name != "id" ~}}
                    {{ column.Name }} = domain.{{ column.Name }},
{{~ end ~}}
{{~ end ~}}
                };
                await FillLogDataHelper.FillLogDataCreate(model, userId);

                var sql = @"INSERT INTO {{ table_name }}({{~ for column in columns ~}}{{~ if column.Name != "id" ~}}{{ column.Name }}{{~ if !for.last ~}}, {{~ end ~}}{{~ end ~}}{{~ end ~}}) 
                           VALUES ({{~ for column in columns ~}}{{~ if column.Name != "id" ~}}@{{ column.Name }}{{~ if !for.last ~}}, {{~ end ~}}{{~ end ~}}{{~ end ~}}) 
                           RETURNING id";
                var result = await _dbConnection.ExecuteScalarAsync<int>(sql, model, transaction: _dbTransaction);
                return result;
            }
            catch (Exception ex)
            {
                throw new RepositoryException("Failed to add {{ entity_name }}", ex);
            }
        }

        public async Task Update({{ entity_name }} domain)
        {
            try
            {
                var userId = await UserSessionHelper.SetCurrentUserAsync(_userRepository, _dbConnection, _dbTransaction);

                var model = new {{ entity_name }}
                {
{{~ for column in columns ~}}
                    {{ column.Name }} = domain.{{ column.Name }},
{{~ end ~}}
                };
                await FillLogDataHelper.FillLogDataUpdate(model, userId);

                var sql = @"UPDATE {{ table_name }} SET {{~ for column in columns ~}}{{~ if column.Name != "id" ~}}{{ column.Name }} = @{{ column.Name }}{{~ if !for.last ~}}, {{~ end ~}}{{~ end ~}}{{~ end ~}} WHERE id = @id";
                var affected = await _dbConnection.ExecuteAsync(sql, model, transaction: _dbTransaction);
                if (affected == 0)
                {
                    throw new RepositoryException("Not found", null);
                }
            }
            catch (Exception ex)
            {
                throw new RepositoryException("Failed to update {{ entity_name }}", ex);
            }
        }

        public async Task<PaginatedList<{{ entity_name }}>> GetPaginated(int pageSize, int pageNumber)
        {
            try
            {
                var sql = "SELECT * FROM {{ table_name }} OFFSET @pageSize * (@pageNumber - 1) LIMIT @pageSize";
                var models = await _dbConnection.QueryAsync<{{ entity_name }}>(sql, new { pageSize, pageNumber }, transaction: _dbTransaction);

                var sqlCount = "SELECT COUNT(*) FROM {{ table_name }}";
                var totalItems = await _dbConnection.ExecuteScalarAsync<int>(sqlCount, transaction: _dbTransaction);

                var domainItems = models.ToList();

                return new PaginatedList<{{ entity_name }}>(domainItems, totalItems, pageNumber, pageSize);
            }
            catch (Exception ex)
            {
                throw new RepositoryException("Failed to get {{ entity_name }}", ex);
            }
        }

        public async Task Delete(int id)
        {
            try
            {
                var sql = "DELETE FROM {{ table_name }} WHERE id = @Id";
                var affected = await _dbConnection.ExecuteAsync(sql, new { Id = id }, transaction: _dbTransaction);

                if (affected == 0)
                {
                    throw new RepositoryException("{{ entity_name }} not found", null);
                }
            }
            catch (Exception ex)
            {
                throw new RepositoryException("Failed to delete {{ entity_name }}", ex);
            }
        }
{{~ for fk in foreign_keys ~}}

        public async Task<List<{{ entity_name }}>> GetBy{{ fk.column_name | to_pascal_case | string.replace "_id" "" }}({{ fk.csharp_type }} {{ fk.column_name }})
        {
            try
            {
                var sql = "SELECT * FROM {{ table_name }} WHERE {{ fk.column_name }} = @{{ fk.column_name }}";
                var models = await _dbConnection.QueryAsync<{{ entity_name }}>(sql, new { {{ fk.column_name }} }, transaction: _dbTransaction);
                return models.ToList();
            }
            catch (Exception ex)
            {
                throw new RepositoryException("Failed to get {{ entity_name }} by {{ fk.column_name }}", ex);
            }
        }
{{~ end ~}}
    }
}